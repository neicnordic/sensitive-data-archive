# Default values for SDA services.
# Declare variables to be passed into your templates.
image:
  repository: "ghcr.io/biobanklab/sensitive-data-archive"
  tag:
  pullPolicy: "Always"

global:
# Path where the sensitive files can be found, default is "/.secrets".
# TLS certificates or C4GH key locations can be set using global.tlsPath or global.c4ghPath respectively,
# this path will be a subpath to the secretsPath.
  secretsPath: /.secrets
  c4ghPath: "c4gh"
  tlsPath: "tls"
  jwtPath: "jwt"

# Name of an injected config file, located in the secretsPath
# If the file is located in a subpath it can be set using the confFilePath
# If no conf file is specified DB and MQ connections will be configured via ENVs
  confFile: config.yaml
  confFilePath: ""

# Deployment can be split into `external` and `internal` components
# by setting deploymentType to the desired type
# if left undefined or `all`, all services are deployed.
  deploymentType: "all"

# standalone version requires a custom schema e.g. isolated
# the files can still be overwritten in container with no change
# options are `federated` or `isolated`
  schemaType: "federated"

  ingress:
    deploy: true
    ingressClassName: "nginx"
    hostName:
      api: ""
      auth: ""
      doa: ""
      download: ""
      s3Inbox: ""
      syncapi: ""
# If the certificates is generated by external providers
# the secrets containing them needs to be created manually.
    secretNames:
      auth: ""
      doa: ""
      download: ""
      s3Inbox: ""
      syncapi: ""
# issuer requires a configured cert-manager
    issuer: ""
    clusterIssuer: ""
    # extra annotations for the ingress
    annotations: {}
    # |
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"

  log:
    level: "info"
    format: "json"

# utilize network isolation
# Make sure youâ€™ve configured a network provider with network policy support.
# There are a number of network providers that support NetworkPolicy, including:
# Calico, Cilium, Kube-router, Romana and Weave Net
  networkPolicy:
    create: false
    brokerNamespace: ""
    databaseNamespace: ""
    externalNamespace: ""
    internalNamespace: ""
    ingressNamespace: ""
    ingressLabelMatch: ""

## RevisionHistory
##  If defined, set the revisionHistoryLimit of the deployment, defaults to 3
##  RevisionHistoryLimit is number of old ReplicaSets to retain to allow rollback.
  # revisionHistory: 3

# Annotations applied to pods of all services.
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  podAnnotations: {}

# If an external PKI infrastructure is used set this to true
  pkiService: false

# Assume RBAC is enabled in the cluster
  rbacEnabled: true

# Extra security context to apply to all pods
# This should be a multi-line string mapping directly to the a map of
# the securityContext to apply to the service pods
  extraSecurityContext: {}

# If no dependency services uses TLS, postgreSQL, RabbitMQ, S3
# TLS can be globally disabled for all serives by setting enabled to false.
# Not to be used in production but handy for testing.
  tls:
    enabled: true
    issuer: ""
    clusterIssuer: ""

# If an external secrets management service is used set this to true
  vaultSecrets: false

# global configurations
  api:
    adminsFileSecret: ""
    adminUsers:
    jwtPubKeyName:
    jwtSecret:
  archive:
    storageType: "" # s3 or posix
  # The six lines below is only used with S3 backend
    s3Url: ""
    s3Bucket: ""
    s3Region: "us-east-1"
    s3ChunkSize: 15 # Chunk size in MB > 5
    s3AccessKey: null
    s3SecretKey: null
    s3CaFile: null
    s3Port: 443
  # The lines below is only used with POSIX backend
    volumePath: "/archive"
    nfsServer: ""
    nfsPath: ""

  backupArchive:
    storageType: "" # s3 or posix
  # The six lines below is only used with S3 backend
    s3Url: ""
    s3Bucket: ""
    s3Region: "us-east-1"
    s3ChunkSize: 15 # Chunk size in MB > 5
    s3AccessKey: null
    s3SecretKey: null
    s3Port: 443
  # The lines below is only used with POSIX backend
    volumePath: "/backup"
    nfsServer: ""
    nfsPath: ""
    copyHeader: false

  auth:
    # @param jwtSecret, name of the secret holding the jwt signing key
    jwtSecret:
    # @param jwtAlg, cipher type of the signing key
    jwtAlg: ES256
    # @param jwtKey, name of the signing key
    jwtKey:
    # @param jwtPub, name of the public signing key
    jwtPub:
    # @param jwtTTL, TTL of the resigned token (hours)
    jwtTTL: 168
    # @param resignJwt, if true (or empty) the jwt will be resigned with the jwtKey
    resignJwt: false
    # @param corsOrigins, domain name of allowed origin for cross-domain requests
    corsOrigins: ""
    # @param corsMethods, allowed methods for cross-domain requests
    corsMethods: ""
    # @param corsCreds, allow credentials in the request, cors is disabled if false
    corsCreds: false
    # @param infoText, name of the project
    infoText: "About Federated EGA"
    # @param inforURL, URL of the project
    inforURL: "https://ega-archive.org/about/projects-and-funders/federated-ega/"

  broker:
    durable: true
    exchange: "sda"
    host: ""
    password: ""
    port: 5671
    ssl: true
    username: ""
    verifyPeer: true
    vhost: "sda"
    prefetchCount: 2

  cega:
    ## @param host, URI to CEGA NSS server users endpoint
    host: ""
    ## @param user, usernamen for accessing the CEGA NSS host
    user: ""
    ## @param password, password for accessing the CEGA NSS host
    password: ""

  c4gh:
    secretName: ""
  # name of the c4gh key file.
    keyFile: ""
  # name of the public file, required for testing
    publicFile: ""
    passphrase: ""
    backupPubKey: ""

  db:
    host: ""
    name: "sda"
    user: ""
    password: ""
    port: 5432
    sslMode: "verify-full"

  doa:
    enabled: false
    outbox:
      enabled: false
      # MQ queue name for files/datasets export requests
      queue: ""
      # Outbox type can be either S3 or POSIX
      type: ""
      # Outbox location with placeholder for the username
      path: ""
      s3Url: ""
      s3Port: 443
      s3Region: ""
      s3Bucket: ""
      s3CaFile: null
      s3AccessKey: null
      s3SecretKey: null
    servicePort: 443
    envFile: env

  download:
    enabled: true
    # session key expiration time in seconds
    # default value = -1 for disabled state
    # a positive integer enables sessions
    # a negative integer disables sessions
    sessionExpiration: 28800
    # this should translate into JSON array of objects
    # with 2 keys iss and jku
    trusted:
      configPath: "iss"
      configFile: "iss.json"
      iss:
        - iss: "https://login.elixir-czech.org/oidc"
          jku: "https://login.elixir-czech.org/oidc/jwk"
    serveUnencryptedData: false

  oidc:
    provider:  "https://login.elixir-czech.org/oidc/"
    jwkPath: "/jwk"
    id: ""
    secret: ""

  inbox:
    servicePort: 2222
    storageType: ""
  # These lines below are only used with posix
    path: "/inbox"
    user: "lega"
    nfsServer: ""
    nfsPath: ""
    existingClaim: ""
  # These lines below are only used with s3
    s3Url: ""
    s3Bucket: "inbox"
    s3AccessKey: null
    s3SecretKey: null
    s3Port: 443
    s3ReadyPath: ""
    s3Region: ""

  reencrypt:
    host: ""
    port: 50051
    timeout: 5

  sync:
    api:
      pass: ""
      user: ""
    brokerQueue: ""
    centerPrefix: ""
    destination:
      storageType: "s3"
      url: ""
      port: 443
      readypath: ""
      accessKey: ""
      secretKey: ""
      bucket: ""
      region: ""
    remote:
      host: ""
      port: ""
      password: ""
      user: ""

##################################
# service specific credentials
credentials:
  api:
    dbUser: ""
    dbPassword: ""
    mqUser: ""
    mqPassword: ""

  doa:
    dbUser: ""
    dbPassword: ""

  download:
    dbUser: ""
    dbPassword: ""

  finalize:
    dbUser: ""
    dbPassword: ""
    mqUser: ""
    mqPassword: ""

  inbox:
    dbUser: ""
    dbPassword: ""
    mqUser: ""
    mqPassword: ""

  ingest:
    dbUser: ""
    dbPassword: ""
    mqUser: ""
    mqPassword: ""

  intercept:
    mqUser: ""
    mqPassword: ""

  mapper:
    dbUser: ""
    dbPassword: ""
    mqUser: ""
    mqPassword: ""

  releasetest:
    dbUser: ""
    dbPassword: ""
    mqUser: ""
    mqPassword: ""

  sync:
    dbUser: ""
    dbPassword: ""
    mqUser: ""
    mqPassword: ""

  verify:
    dbUser: ""
    dbPassword: ""
    mqUser: ""
    mqPassword: ""

##################################
# Service specific settings

api:
  name: api
  replicaCount: 2
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "256Mi"
      cpu: "250m"
# Extra annotations to attach to the service pods
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""

auth:
  name: auth
  replicaCount: 2
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "256Mi"
      cpu: "250m"
# Extra annotations to attach to the service pods
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""

doa:
  name: doa
  repository: ghcr.io/neicnordic/sda-doa
  imageTag: v1.6.62
  imagePullPolicy: IfNotPresent
  replicaCount: 2
  resources:
    requests:
      memory: "256Mi"
      cpu: "100m"
    limits:
      memory: "1024Mi"
      cpu: "2000m"
  debugPort: 1234
  logpath: "/tmp/logs"
  keystorePass: "changeit"
# Extra annotations to attach to the service pods
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""

download:
  name: download
  replicaCount: 2
  resources:
    requests:
      memory: "256Mi"
      cpu: "100m"
    limits:
      memory: "512Mi"
      cpu: "1000m"
# Extra annotations to attach to the service pods
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""

finalize:
  name: finalize
  replicaCount: 1
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "256Mi"
      cpu: "250m"
# Extra annotations to attach to the service pods
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""

ingest:
  name: ingest
  replicaCount: 1
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "512Mi"
      cpu: "2000m"
# Extra annotations to attach to the service pods
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""

intercept:
  deploy: true
  name: ingest
  replicaCount: 1
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "256Mi"
      cpu: "250m"
# Extra annotations to attach to the service pods
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""

mapper:
  replicaCount: 1
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "256Mi"
      cpu: "2000m"
# Extra annotations to attach to the service pods
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""

reencrypt:
  replicaCount: 1
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "256Mi"
      cpu: "500m"
# Extra annotations to attach to the service pods
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""

s3Inbox:
  name: s3Inbox
  replicaCount: 2
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "1024Mi"
      cpu: "1000m"
# Extra annotations to attach to the service pods
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""

sftpInbox:
  name: sftpInbox
  replicaCount: 2
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "256Mi"
      cpu: "250m"
  keystorePass: "changeit"
  nodeHostname: ""
# Extra annotations to attach to the pod
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""

sync:
  name: sync
  replicaCount: 1
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "512Mi"
      cpu: "500m"
# Extra annotations to attach to the service pods
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""

syncapi:
  name: sync-api
  replicaCount: 1
  resources:
    requests:
      memory: "64Mi"
      cpu: "100m"
    limits:
      memory: "256Mi"
      cpu: "500m"
# Extra annotations to attach to the service pods
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""

releasetest:
  run: false
  repository: biobanklab/sda-helm-tests-support
  imageTag: latest
  imagePullPolicy: IfNotPresent
  tls:
    secretName: ""
  secrets:
    accessToken:

verify:
  replicaCount: 1
  repository: ghcr.io/biobanklab/sda-pipeline
  imageTag: v0.4.27
  imagePullPolicy: IfNotPresent
  resources:
    requests:
      memory: "128Mi"
      cpu: "100m"
    limits:
      memory: "256Mi"
      cpu: "2000m"
# Extra annotations to attach to the pod
# This should be a multi-line string mapping directly to the a map of
# the annotations to apply to the service pods
  annotations: {}
  tls:
    secretName: ""
